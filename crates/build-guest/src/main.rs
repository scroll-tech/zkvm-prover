use std::env;

use eyre::Ok;
use openvm_native_compiler::ir::DIGEST_SIZE;
use openvm_sdk::{commit::AppExecutionCommit, config::SdkVmConfig, Sdk, F};
use openvm_stark_sdk::{openvm_stark_backend::p3_field::PrimeField32, p3_baby_bear::BabyBear};
use snark_verifier_sdk::snark_verifier::loader::halo2::halo2_ecc::halo2_base::halo2_proofs::halo2curves::bn256::Fr;

mod verifier;
use verifier::dump_verifier;

mod builder;

fn write_commitments(commitments: [[u32; 8]; 2], output: &str) -> eyre::Result<()> {
    let content = format!(
        "//! Generated by crates/build-guest. DO NOT OVERWRITE!\n\npub const EXE_COMMIT: [u32; 8] = {:?};\npub const LEAF_COMMIT: [u32; 8] = {:?};\n",
        commitments[0], commitments[1],
    );
    std::fs::write(output, content)?;
    Ok(())
}

// python: import json; compress = lambda p: sum(v * pow(2013265921, i) for i, v in enumerate(json.loads(open(p).read()))).to_bytes(32, 'little').hex()
fn compress_commitment(commitment: &[u32; 8]) -> Fr {
    let order = Fr::from(BabyBear::ORDER_U32 as u64);
    let mut base = Fr::one();
    let mut ret = Fr::zero();

    for v in commitment {
        ret += Fr::from(*v as u64) * base;
        base *= order;
    }

    ret
}

#[derive(Debug)]
pub(crate) struct BuildConfig {
    pub(crate) features: Vec<String>,
    pub(crate) filename_suffix: String,
}

fn get_build_config(project_name: &str) -> Vec<BuildConfig> {
    match project_name {
        "chunk" => vec![
            BuildConfig {
                features: vec![],
                filename_suffix: "_rv32".to_string(),
            },
            BuildConfig {
                features: vec!["openvm".to_string()],
                filename_suffix: "".to_string(),
            },
        ],
        "batch" => vec![BuildConfig {
            features: vec![],
            filename_suffix: "".to_string(),
        }],
        "bundle" => vec![
            BuildConfig {
                features: vec![],
                filename_suffix: "_euclidv1".to_string(),
            },
            BuildConfig {
                features: vec!["euclidv2".to_string()],
                filename_suffix: "".to_string(),
            },
        ],
        _ => unreachable!("[BUILD-GUEST] unsupported project name: {project_name}"),
    }
}

pub fn main() -> eyre::Result<()> {
    // cwd to manifest_dir
    env::set_current_dir(env::var("CARGO_MANIFEST_DIR")?)?;

    let dir_workspace = cargo_metadata::MetadataCommand::new()
        .exec()?
        .workspace_root;

    let project_names_var = env::var("BUILD_PROJECT");
    let project_names = project_names_var
        .as_ref()
        .map(|s| s.split(',').collect::<Vec<_>>())
        .unwrap_or_else(|_| vec!["chunk", "batch", "bundle"]);

    println!("[BUILD-GUEST] projects={:#?}", project_names);

    // Step1: generate leaf commitments
    for project_name in &project_names {
        let dir_project = format!("{dir_workspace}/crates/circuits/{project_name}-circuit");
        let app_config = builder::load_app_config(&dir_project)?;
        let app_pk = Sdk::new().app_keygen(app_config.clone())?;
        let leaf_vm_verifier_commit: [F; DIGEST_SIZE] = app_pk
            .leaf_committed_exe
            .committed_program
            .commitment
            .into();
        let leaf_vm_verifier_commit = leaf_vm_verifier_commit.map(|x| x.as_canonical_u32());
        std::fs::write(
            format!("{dir_project}/leaf.commit"),
            format!("{:?}", leaf_vm_verifier_commit),
        )?;
    }
    println!("Leaf commitments generated");
    return Ok(());

    // Step2: export the babybear native proof verifier.
    // dump root_verifier in workspace directory.
    // if project_names includes "batch" or "bundle", then generate the root_verifier
    if project_names
        .iter()
        .any(|&name| name == "batch" || name == "bundle")
    {
        let root_verifier = format!("{dir_workspace}/crates/build-guest/root_verifier.asm");
        dump_verifier(&root_verifier);
        println!("root verifier generated: {}", root_verifier);
    }

    // Step3: generate exes and exe commits
    for project_name in &project_names {
        let dir_project = format!("{dir_workspace}/crates/circuits/{project_name}-circuit");
        let build_configs = get_build_config(project_name);

        for build_config in build_configs {
            println!(
                "[BUILD-GUEST] START build project={project_name} with build-config={build_config:?}"
            );
            let start_time = std::time::Instant::now();

            let app_config = builder::load_app_config(&dir_project)?;

            let fd_app_exe = format!("app{}.vmexe", build_config.filename_suffix);
            let elf = builder::build(&dir_project, &build_config.features)?;
            let app_exe = builder::transpile(
                &dir_project,
                elf,
                Some(fd_app_exe.as_str()),
                app_config.clone(),
            )?;
            let app_committed_exe =
                Sdk::new().commit_app_exe(app_config.app_fri_params.fri_params.clone(), app_exe)?;

            use openvm_circuit::arch::VmConfig;
            let exe_commit: [F; DIGEST_SIZE] = app_committed_exe
                .compute_exe_commit(
                    &<SdkVmConfig as VmConfig<F>>::system(&app_config.app_vm_config).memory_config,
                )
                .into();
            let exe_commit: [u32; DIGEST_SIZE] = exe_commit.map(|x| x.as_canonical_u32());
            std::fs::write(
                format!("{dir_project}/exe{}.commit", build_config.filename_suffix),
                format!("{:?}", exe_commit),
            )?;

            println!(
                "[BUILD-GUEST] OK build project={project_name} with build-config={build_config:?} in time={:?}",
                start_time.elapsed(),
            );
        }
    }

    // Step4: generate the onchain bn254 commitments
    for build_config in get_build_config("bundle") {
        let dir_project = format!("{dir_workspace}/crates/circuits/bundle-circuit");
        let leaf_comm = std::fs::read_to_string(format!("{dir_project}/leaf.commit"))?;
        let leaf_comm: [u32; DIGEST_SIZE] = serde_json::from_str(&leaf_comm)?;
        let exe_comm = std::fs::read_to_string(format!(
            "{dir_project}/exe{}.commit",
            build_config.filename_suffix
        ))?;
        let exe_comm: [u32; DIGEST_SIZE] = serde_json::from_str(&exe_comm)?;
        let digest_1 = compress_commitment(&exe_comm)
            .to_bytes()
            .into_iter()
            .rev()
            .collect::<Vec<u8>>();
        let filename = format!(
            "{dir_workspace}/crates/circuits/bundle-circuit/digest_1{}",
            build_config.filename_suffix,
        );
        std::fs::write(&filename, &digest_1)?;

        let digest_2 = compress_commitment(&leaf_comm)
            .to_bytes()
            .into_iter()
            .rev()
            .collect::<Vec<u8>>();
        let filename = format!(
            "{dir_workspace}/crates/circuits/bundle-circuit/digest_2{}",
            build_config.filename_suffix,
        );
        std::fs::write(&filename, &digest_2)?;
    }

    println!("[BUILD-GUEST] OK");

    Ok(())
}
