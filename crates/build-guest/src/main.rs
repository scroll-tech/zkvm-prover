#![allow(clippy::ptr_arg)]
//! Build script for guest circuits (chunk, batch, bundle).
//!
//! This script handles several stages:
//! 1. Generating leaf commitments for circuit verifiers.
//! 2. Generating the root verifier assembly code (if batch or bundle is built).
//! 3. Building guest programs (ELF), transpiling them to VM executables (.vmexe),
//!    and generating executable commitments.
//!
//! Environment variables control behavior:
//! - `BUILD_PROJECT`: Comma-separated list of projects to build (e.g., "chunk,batch"). Defaults to "chunk,batch,bundle".
//! - `BUILD_STAGES`: Comma-separated list of stages to run (e.g., "stage1,stage3"). Defaults to "stage1,stage2,stage3".

use std::{
    collections::{BTreeSet, HashMap},
    env,
    fs::read_to_string,
    path::{Path, PathBuf},
    time::Instant,
};

use dotenv::dotenv;
use eyre::Result;
use openvm_build::GuestOptions;
use openvm_native_compiler::ir::DIGEST_SIZE;
use openvm_sdk::{
    F, Sdk,
    commit::CommitBytes,
    config::{AppConfig, SdkVmConfig},
    fs::write_exe_to_file,
};
use openvm_stark_sdk::{openvm_stark_backend::p3_field::PrimeField32, p3_bn254_fr::Bn254Fr};
use snark_verifier_sdk::snark_verifier::loader::evm::compile_solidity;

mod verifier;

pub(crate) const LOG_PREFIX: &str = "[build-guest]";

/// File descriptor for app openvm config.
const FD_APP_CONFIG: &str = "openvm.toml";

/// Writes a commitment array to a Rust source file.
fn write_commitment(output_path: &PathBuf, commitment: [u32; DIGEST_SIZE]) -> Result<()> {
    let content = format!(
        "#![cfg_attr(rustfmt, rustfmt_skip)]\n//! Generated by crates/build-guest. DO NOT EDIT!\n\npub const COMMIT: [u32; {DIGEST_SIZE}] = {commitment:?};\n"
    );
    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    std::fs::write(output_path, content)?;
    println!("{LOG_PREFIX} Wrote commitment to {}", output_path.display());
    Ok(())
}

/// Writes a commitment array as hex
fn write_commitment_as_evm_hex(
    output_path: &PathBuf,
    commitment: [u32; DIGEST_SIZE],
) -> Result<()> {
    let digest_bytes = compress_commitment(&commitment)
        .value
        .to_bytes()
        .into_iter()
        .rev() // To big endian
        .collect::<Vec<u8>>();
    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    std::fs::write(output_path, hex::encode(digest_bytes))?;
    println!("{LOG_PREFIX} Wrote commitment to {}", output_path.display());
    Ok(())
}

/// Compresses an 8-element u32 commitment into a single Fr element.
/// Used for generating digests compatible with on-chain verifiers.
fn compress_commitment(commitment: &[u32; DIGEST_SIZE]) -> Bn254Fr {
    CommitBytes::from_u32_digest(commitment).to_bn254()
}

/// Stage 1: Generates and writes leaf commitments for each specified project.
fn run_stage1_leaf_commitments(
    project_names: &[&str],
    workspace_dir: &Path,
    release_output_dir: &PathBuf,
) -> Result<HashMap<String, [u32; DIGEST_SIZE]>> {
    println!("{LOG_PREFIX} === Stage 1: Generating Leaf Commitments ===");
    let mut leaf_commitments = HashMap::new();
    for &project_name in project_names {
        println!("{LOG_PREFIX} Processing project: {project_name}");
        let project_dir = workspace_dir
            .join("crates")
            .join("circuits")
            .join(format!("{project_name}-circuit"));
        let path_app_config = Path::new(&project_dir).join(FD_APP_CONFIG);
        let app_config: AppConfig<SdkVmConfig> =
            toml::from_str(&read_to_string(&path_app_config).unwrap()).unwrap();

        // Generate public key (which includes leaf commitment)
        let app_pk = Sdk::new().app_keygen(app_config.clone())?;
        let leaf_vm_verifier_commit_f: [F; DIGEST_SIZE] = app_pk
            .leaf_committed_exe
            .committed_program
            .commitment
            .into();
        let leaf_vm_verifier_commit_u32 = leaf_vm_verifier_commit_f.map(|f| f.as_canonical_u32());
        leaf_commitments.insert(project_name.to_string(), leaf_vm_verifier_commit_u32);

        // Write the commitment to a .rs file
        let output_path = project_dir.join(format!("{project_name}_leaf_commit.rs"));
        write_commitment(&output_path, leaf_vm_verifier_commit_u32)?;

        // Special handling for bundle project: generate digest_2
        if project_name == "bundle" {
            println!("{LOG_PREFIX} Generating digest_2 for bundle project...");
            let output_path = release_output_dir.join(project_name).join("digest_2.hex");
            write_commitment_as_evm_hex(&output_path, leaf_vm_verifier_commit_u32)?;
        }
    }
    println!("{LOG_PREFIX} === Stage 1 Finished ===");
    Ok(leaf_commitments)
}

/// Stage 2: Generates the root verifier assembly code.
fn run_stage2_root_verifier(project_names: &[&str], workspace_dir: &Path) -> Result<()> {
    println!("{LOG_PREFIX} === Stage 2: Generating Root Verifier ===");
    use openvm_sdk::{config::AggStarkConfig, keygen::AggStarkProvingKey};
    // Only generate if "batch" or "bundle" is being built, as they use recursive verification.
    if project_names
        .iter()
        .any(|&name| name == "batch" || name == "bundle")
    {
        println!("{LOG_PREFIX} Generating root verifier assembly...");
        let root_verifier_path = workspace_dir
            .join("crates")
            .join("build-guest")
            .join("root_verifier.asm");

        println!("generating AggStarkProvingKey");
        let agg_stark_pk = AggStarkProvingKey::keygen(AggStarkConfig::default());

        println!("generating root_verifier.asm");
        let asm = openvm_sdk::Sdk::new().generate_root_verifier_asm(&agg_stark_pk);
        std::fs::write(&root_verifier_path, asm).expect("fail to write");

        println!(
            "{LOG_PREFIX} Root verifier generated at: {}",
            root_verifier_path.display()
        );
    } else {
        println!(
            "{LOG_PREFIX} Skipping root verifier generation (not needed for selected projects)."
        );
    }
    println!("{LOG_PREFIX} === Stage 2 Finished ===");
    Ok(())
}

/// Stage 3: Builds guest programs, transpiles them, and generates executable commitments.
fn run_stage3_exe_commits(
    project_names: &[&str],
    workspace_dir: &Path,
    release_output_dir: &PathBuf,
) -> Result<HashMap<String, [u32; DIGEST_SIZE]>> {
    println!("{LOG_PREFIX} === Stage 3: Generating Executable Commitments ===");
    let mut exe_commitments = HashMap::new();
    for &project_name in project_names {
        let project_path = workspace_dir
            .join("crates")
            .join("circuits")
            .join(format!("{project_name}-circuit"));

        println!("{LOG_PREFIX} Processing project: {project_name}");

        let start_time = Instant::now();
        println!("{LOG_PREFIX} Starting build...");

        let project_dir = project_path.to_str().expect("Invalid path");
        // First read the app config specified in the project's root directory.
        let path_app_config = Path::new(project_dir).join(FD_APP_CONFIG);
        let app_config: AppConfig<SdkVmConfig> =
            toml::from_str(&read_to_string(&path_app_config).unwrap()).unwrap();
        println!(
            "{project_dir} app config: {}",
            toml::to_string_pretty(&app_config).unwrap()
        );

        // copy path_app_config as ${release_output_dir}/${project_name}/${FD_APP_CONFIG}
        let output_path = release_output_dir.join(project_name).join(FD_APP_CONFIG);
        if let Some(parent) = output_path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        std::fs::copy(&path_app_config, &output_path)?;
        println!("{LOG_PREFIX} Copied config to {}", output_path.display());

        // 1. Build ELF

        // Store current directory and change to project directory
        let original_dir = env::current_dir()?;
        env::set_current_dir(&project_path)?;
        println!(
            "{LOG_PREFIX} Changed working directory to: {}",
            project_path.display()
        );
        let guest_opts = GuestOptions::default();
        let guest_opts = guest_opts.with_profile("maxperf".to_string());
        let elf = Sdk::new()
            .build(
                guest_opts,
                &app_config.app_vm_config,
                project_dir,
                &Default::default(),
                None,
            )
            .inspect_err(|_err| {
                println!("{LOG_PREFIX} Building failed in {}", project_dir);
            })?;
        println!("{LOG_PREFIX} Built ELF");

        // Revert to original directory
        env::set_current_dir(&original_dir)?;
        println!(
            "{LOG_PREFIX} Reverted working directory to: {}",
            original_dir.display()
        );

        // 2. Transpile ELF to VM Executable
        let transpiler = app_config.app_vm_config.transpiler();
        let app_exe = Sdk::new().transpile(elf, transpiler)?;

        // Create the assets dir if not already present.
        let path_assets = Path::new(release_output_dir).join(project_name);
        std::fs::create_dir_all(&path_assets)?;
        // Write exe to disc.
        let path_app_exe: PathBuf = path_assets.join("app.vmexe");
        write_exe_to_file(app_exe.clone(), &path_app_exe)?;

        println!("{LOG_PREFIX} exe written to {path_app_exe:?}");

        // 3. Commit VM Executable
        let app_committed_exe =
            Sdk::new().commit_app_exe(app_config.app_fri_params.fri_params, app_exe)?;

        // 4. Compute and Write Executable Commitment
        use openvm_circuit::arch::VmConfig;
        let exe_commit_f: [F; DIGEST_SIZE] = app_committed_exe
            .compute_exe_commit(
                &<SdkVmConfig as VmConfig<F>>::system(&app_config.app_vm_config).memory_config,
            )
            .into();
        let exe_commit_u32: [u32; DIGEST_SIZE] = exe_commit_f.map(|f| f.as_canonical_u32());
        exe_commitments.insert(project_name.to_string(), exe_commit_u32);

        let commit_filename = format!("{project_name}_exe_commit.rs");

        let output_path = Path::new(project_dir).join(&commit_filename);
        write_commitment(&output_path, exe_commit_u32)?;

        // Special handling for bundle project: generate digest_1
        if project_name == "bundle" {
            println!("{LOG_PREFIX} Generating digest_1 for bundle project...",);
            let output_path = release_output_dir.join(project_name).join("digest_1.hex");
            write_commitment_as_evm_hex(&output_path, exe_commit_u32)?;
        }

        println!(
            "{LOG_PREFIX} Finished build for config in {:?}",
            start_time.elapsed()
        );
    }
    println!("{LOG_PREFIX} === Stage 3 Finished ===");
    Ok(exe_commitments)
}

/// Stage 4: Dumps VK data to a JSON file if both exe and leaf commitments are available.
fn run_stage4_dump_vk_json(
    release_output_dir: &PathBuf,
    leaf_commitments: Option<HashMap<String, [u32; DIGEST_SIZE]>>,
    exe_commitments: Option<HashMap<String, [u32; DIGEST_SIZE]>>,
) -> Result<()> {
    println!("{LOG_PREFIX} === Stage 4: Dumping VK JSON ===");

    // Only dump VKs when both exe_commitments and leaf_commitments are available
    if let (Some(exe_commitments), Some(leaf_commitments)) = (&exe_commitments, &leaf_commitments) {
        #[derive(Default, Debug, serde::Serialize)]
        struct VKDump {
            pub chunk_vk: String,
            pub batch_vk: String,
            pub bundle_vk: String,
        }
        let [chunk_vk, batch_vk, bundle_vk] = ["chunk", "batch", "bundle"].map(|circuit| {
            if let (Some(exe), Some(leaf)) =
                (exe_commitments.get(circuit), leaf_commitments.get(circuit))
            {
                let app_vk = scroll_zkvm_types::types_agg::StarkVerificationKey::new(*exe, *leaf)
                    .to_bytes_bincode();

                use base64::{Engine, prelude::BASE64_STANDARD};
                let app_vk = BASE64_STANDARD.encode(app_vk);
                println!("{circuit}: {app_vk}");
                app_vk
            } else {
                String::new() // Empty string for circuits that weren't built
            }
        });

        let dump = VKDump {
            chunk_vk,
            batch_vk,
            bundle_vk,
        };

        let output_path = release_output_dir.join("verifier").join("openVmVk.json");
        if let Some(parent) = output_path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        let f = std::fs::File::create(output_path)?;
        serde_json::to_writer(f, &dump)?;
        println!(
            "{LOG_PREFIX} openVmVk.json: {}",
            serde_json::to_string_pretty(&dump)?
        );
        println!("{LOG_PREFIX} VK data written to openVmVk.json");
    }
    Ok(())
}

fn run_stage5_dump_evm_verifier(verifier_output_dir: &PathBuf, recompute_mode: bool) -> Result<()> {
    println!("{LOG_PREFIX} === Stage 5: Dumping EVM VERIFIER ===");
    let path_verifier_sol = verifier_output_dir.join("verifier.sol");
    let path_verifier_bin = verifier_output_dir.join("verifier.bin");
    if let Some(parent) = path_verifier_bin.parent() {
        std::fs::create_dir_all(parent)?;
    }

    let verifier_sol = if recompute_mode {
        verifier::generate_evm_verifier()?
    } else {
        verifier::download_evm_verifier()?
    };
    std::fs::write(&path_verifier_sol, &verifier_sol)?;
    println!("{LOG_PREFIX} verifier_sol written to {path_verifier_sol:?}");

    let verifier_bin = compile_solidity(&verifier_sol);
    std::fs::write(&path_verifier_bin, &verifier_bin)?;
    println!("{LOG_PREFIX} verifier_bin written to {path_verifier_bin:?}");

    println!("{LOG_PREFIX} === Stage 5 Finished ===");
    Ok(())
}

pub fn main() -> Result<()> {
    // Set current directory to the crate's root
    let manifest_dir = env::var("CARGO_MANIFEST_DIR")?;
    env::set_current_dir(&manifest_dir)?;
    println!("{LOG_PREFIX} Running in directory: {}", manifest_dir);

    // Load .env file if present
    dotenv().ok();

    // Determine workspace root
    let metadata = cargo_metadata::MetadataCommand::new().exec()?;
    let workspace_dir = metadata.workspace_root.into_std_path_buf();
    println!("{LOG_PREFIX} Workspace root: {}", workspace_dir.display());

    let release_output_dir: std::path::PathBuf = workspace_dir.join("releases").join("dev");
    std::fs::create_dir_all(&release_output_dir)?;
    println!(
        "{LOG_PREFIX} Release output directory: {}",
        release_output_dir.display()
    );

    // Determine which projects to build
    let projects_to_build_str = env::var("BUILD_PROJECT");
    let projects_to_build = projects_to_build_str
        .as_ref()
        .map(|s| s.split(',').filter(|p| !p.is_empty()).collect::<Vec<_>>())
        .unwrap_or_else(|_| vec!["chunk", "batch", "bundle"]); // Default projects

    if projects_to_build.is_empty() {
        println!("{LOG_PREFIX} No projects specified in BUILD_PROJECT. Exiting.");
        return Ok(());
    }
    println!("{LOG_PREFIX} Projects to build: {:?}", projects_to_build);

    // Determine which stages to run
    let stages_env =
        env::var("BUILD_STAGES").unwrap_or_else(|_| "stage1,stage2,stage3".to_string());
    let stages_to_run: BTreeSet<&str> = if stages_env.trim().is_empty() {
        // If empty string is provided, run all stages
        ["stage1", "stage2", "stage3"].iter().cloned().collect()
    } else {
        stages_env.split(',').filter(|s| !s.is_empty()).collect()
    };

    if stages_to_run.is_empty() {
        println!("{LOG_PREFIX} No stages specified in BUILD_STAGES. Exiting.");
        return Ok(());
    }
    println!("{LOG_PREFIX} Stages to run: {:?}", stages_to_run);

    // Execute selected stages
    let leaf_commitments = if stages_to_run.contains("stage1") {
        Some(run_stage1_leaf_commitments(
            &projects_to_build,
            &workspace_dir,
            &release_output_dir,
        )?)
    } else {
        println!("{LOG_PREFIX} Skipping Stage 1: Leaf Commitments");
        None
    };

    if stages_to_run.contains("stage2") {
        run_stage2_root_verifier(&projects_to_build, &workspace_dir)?;
    } else {
        println!("{LOG_PREFIX} Skipping Stage 2: Root Verifier");
    };

    let exe_commitments = if stages_to_run.contains("stage3") {
        Some(run_stage3_exe_commits(
            &projects_to_build,
            &workspace_dir,
            &release_output_dir,
        )?)
    } else {
        println!("{LOG_PREFIX} Skipping Stage 3: Exe Commits");
        None
    };

    run_stage4_dump_vk_json(&release_output_dir, leaf_commitments, exe_commitments)?;

    env::set_current_dir(&workspace_dir)?;
    run_stage5_dump_evm_verifier(
        &release_output_dir.join("verifier"),
        stages_to_run.contains("stage5"),
    )?;

    println!("{LOG_PREFIX} Build process completed successfully.");
    Ok(())
}
