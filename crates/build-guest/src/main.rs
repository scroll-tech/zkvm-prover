//! Build script for guest circuits (chunk, batch, bundle).
//!
//! This script handles several stages:
//! 1. Generating leaf commitments for circuit verifiers.
//! 2. Generating the root verifier assembly code (if batch or bundle is built).
//! 3. Building guest programs (ELF), transpiling them to VM executables (.vmexe),
//!    and generating executable commitments.
//!
//! Environment variables control behavior:
//! - `BUILD_PROJECT`: Comma-separated list of projects to build (e.g., "chunk,batch"). Defaults to "chunk,batch,bundle".
//! - `BUILD_STAGES`: Comma-separated list of stages to run (e.g., "stage1,stage3"). Defaults to "stage1,stage2,stage3".

use std::{
    collections::{HashMap, HashSet},
    env,
    path::Path,
    time::Instant,
};

use dotenv::dotenv;
use eyre::Result;
use openvm_native_compiler::ir::DIGEST_SIZE;
use openvm_sdk::{config::SdkVmConfig, Sdk, F};
use openvm_stark_sdk::{openvm_stark_backend::p3_field::PrimeField32, p3_baby_bear::BabyBear};
use snark_verifier_sdk::snark_verifier::loader::halo2::halo2_ecc::halo2_base::halo2_proofs::halo2curves::bn256::Fr;

mod builder;

const LOG_PREFIX: &str = "[build-guest]";

/// Writes a commitment array to a Rust source file.
fn write_commitment(output_path: &str, commitment: [u32; DIGEST_SIZE]) -> Result<()> {
    let content = format!(
        "#![cfg_attr(rustfmt, rustfmt_skip)]\n//! Generated by crates/build-guest. DO NOT EDIT!\n\npub const COMMIT: [u32; {DIGEST_SIZE}] = {commitment:?};\n"
    );
    std::fs::write(output_path, content)?;
    println!("{LOG_PREFIX} Wrote commitment to {output_path}");
    Ok(())
}

/// Compresses an 8-element u32 commitment into a single Fr element.
/// Used for generating digests compatible with on-chain verifiers.
fn compress_commitment(commitment: &[u32; DIGEST_SIZE]) -> Fr {
    // Ensure DIGEST_SIZE is 8 for this specific compression logic
    assert_eq!(
        DIGEST_SIZE, 8,
        "compress_commitment assumes DIGEST_SIZE is 8"
    );
    let order = Fr::from(BabyBear::ORDER_U32 as u64);
    let mut base = Fr::one();
    let mut compressed_value = Fr::zero();

    for val in commitment {
        compressed_value += Fr::from(*val as u64) * base;
        base *= order;
    }

    compressed_value
}

/// Stage 1: Generates and writes leaf commitments for each specified project.
fn run_stage1_leaf_commitments(
    project_names: &[&str],
    workspace_dir: &Path,
) -> Result<HashMap<String, [u32; DIGEST_SIZE]>> {
    println!("{LOG_PREFIX} === Stage 1: Generating Leaf Commitments ===");
    let mut leaf_commitments = HashMap::new();
    for &project_name in project_names {
        println!("{LOG_PREFIX} Processing project: {project_name}");
        let project_dir = workspace_dir
            .join("crates")
            .join("circuits")
            .join(format!("{project_name}-circuit"));
        let app_config = builder::load_app_config(project_dir.to_str().expect("Invalid path"))?;

        // Generate public key (which includes leaf commitment)
        let app_pk = Sdk::new().app_keygen(app_config.clone())?;
        let leaf_vm_verifier_commit_f: [F; DIGEST_SIZE] = app_pk
            .leaf_committed_exe
            .committed_program
            .commitment
            .into();
        let leaf_vm_verifier_commit_u32 = leaf_vm_verifier_commit_f.map(|f| f.as_canonical_u32());
        leaf_commitments.insert(project_name.to_string(), leaf_vm_verifier_commit_u32);

        // Write the commitment to a .rs file
        let output_path = project_dir.join(format!("{project_name}_leaf_commit.rs"));
        write_commitment(
            output_path.to_str().expect("Invalid path"),
            leaf_vm_verifier_commit_u32,
        )?;

        // Special handling for bundle project: generate digest_2
        if project_name == "bundle" {
            println!("{LOG_PREFIX} Generating digest_2 for bundle project...");
            let digest_2_bytes = compress_commitment(&leaf_vm_verifier_commit_u32)
                .to_bytes()
                .into_iter()
                .rev() // Ensure correct byte order if needed (verify endianness requirement)
                .collect::<Vec<u8>>();
            let digest_2_path = project_dir.join("digest_2");
            std::fs::write(&digest_2_path, &digest_2_bytes)?;
            println!("{LOG_PREFIX} Wrote digest_2 to {}", digest_2_path.display());
        }
    }
    println!("{LOG_PREFIX} === Stage 1 Finished ===");
    Ok(leaf_commitments)
}

/// Stage 2: Generates the root verifier assembly code.
fn run_stage2_root_verifier(project_names: &[&str], workspace_dir: &Path) -> Result<()> {
    println!("{LOG_PREFIX} === Stage 2: Generating Root Verifier ===");
    use openvm_sdk::{config::AggStarkConfig, keygen::AggStarkProvingKey};
    // Only generate if "batch" or "bundle" is being built, as they use recursive verification.
    if project_names
        .iter()
        .any(|&name| name == "batch" || name == "bundle")
    {
        println!("{LOG_PREFIX} Generating root verifier assembly...");
        let root_verifier_path = workspace_dir
            .join("crates")
            .join("build-guest")
            .join("root_verifier.asm");

        println!("generating AggStarkProvingKey");
        let (agg_stark_pk, _) =
            AggStarkProvingKey::dummy_proof_and_keygen(AggStarkConfig::default());

        println!("generating root_verifier.asm");
        let asm = openvm_sdk::Sdk::new().generate_root_verifier_asm(&agg_stark_pk);
        std::fs::write(&root_verifier_path, asm).expect("fail to write");

        println!(
            "{LOG_PREFIX} Root verifier generated at: {}",
            root_verifier_path.display()
        );
    } else {
        println!(
            "{LOG_PREFIX} Skipping root verifier generation (not needed for selected projects)."
        );
    }
    println!("{LOG_PREFIX} === Stage 2 Finished ===");
    Ok(())
}

/// Stage 3: Builds guest programs, transpiles them, and generates executable commitments.
fn run_stage3_exe_commits(
    project_names: &[&str],
    workspace_dir: &Path,
) -> Result<HashMap<String, [u32; DIGEST_SIZE]>> {
    println!("{LOG_PREFIX} === Stage 3: Generating Executable Commitments ===");
    let mut exe_commitments = HashMap::new();
    for &project_name in project_names {
        let project_path = workspace_dir
            .join("crates")
            .join("circuits")
            .join(format!("{project_name}-circuit"));

        println!("{LOG_PREFIX} Processing project: {project_name}");

        let start_time = Instant::now();
        println!("{LOG_PREFIX} Starting build...");

        let project_dir = project_path.to_str().expect("Invalid path");
        let app_config = builder::load_app_config(project_dir)?;

        // Store current directory and change to project directory
        let original_dir = env::current_dir()?;
        env::set_current_dir(&project_path)?;
        println!(
            "{LOG_PREFIX} Changed working directory to: {}",
            project_path.display()
        );

        // 1. Build ELF
        let elf = builder::build(project_dir, Vec::<String>::new(), &app_config.app_vm_config)
            .inspect_err(|_err| {
                println!("{LOG_PREFIX} Building failed in {}", project_dir);
            })?;
        println!("{LOG_PREFIX} Built ELF");

        // Revert to original directory
        env::set_current_dir(&original_dir)?;
        println!(
            "{LOG_PREFIX} Reverted working directory to: {}",
            original_dir.display()
        );

        // 2. Transpile ELF to VM Executable
        let vmexe_filename = String::from("app.vmexe");
        let app_exe =
            builder::transpile(project_dir, elf, Some(&vmexe_filename), app_config.clone())?;
        println!("{LOG_PREFIX} Transpiled to VM Executable: {vmexe_filename}");

        // 3. Commit VM Executable
        let app_committed_exe =
            Sdk::new().commit_app_exe(app_config.app_fri_params.fri_params, app_exe)?;

        // 4. Compute and Write Executable Commitment
        use openvm_circuit::arch::VmConfig;
        let exe_commit_f: [F; DIGEST_SIZE] = app_committed_exe
            .compute_exe_commit(
                &<SdkVmConfig as VmConfig<F>>::system(&app_config.app_vm_config).memory_config,
            )
            .into();
        let exe_commit_u32: [u32; DIGEST_SIZE] = exe_commit_f.map(|f| f.as_canonical_u32());
        exe_commitments.insert(project_name.to_string(), exe_commit_u32);

        let commit_filename = format!("{project_name}_exe_commit.rs");
        let output_path = Path::new(project_dir).join(&commit_filename);
        write_commitment(output_path.to_str().expect("Invalid path"), exe_commit_u32)?;

        // Special handling for bundle project: generate digest_1
        if project_name == "bundle" {
            println!("{LOG_PREFIX} Generating digest_1 for bundle project...",);
            let digest_1_bytes = compress_commitment(&exe_commit_u32)
                .to_bytes()
                .into_iter()
                .rev() // Ensure correct byte order
                .collect::<Vec<u8>>();
            let digest_1_filename = String::from("digest_1");
            let digest_1_path = Path::new(project_dir).join(&digest_1_filename);
            std::fs::write(&digest_1_path, &digest_1_bytes)?;
            println!(
                "{LOG_PREFIX} Wrote {} to {}",
                digest_1_filename,
                digest_1_path.display()
            );
        }

        println!(
            "{LOG_PREFIX} Finished build for config in {:?}",
            start_time.elapsed()
        );
    }
    println!("{LOG_PREFIX} === Stage 3 Finished ===");
    Ok(exe_commitments)
}

/// Stage 4: Dumps VK data to a JSON file if both exe and leaf commitments are available.
fn run_stage4_dump_vk_json(
    leaf_commitments: Option<HashMap<String, [u32; DIGEST_SIZE]>>,
    exe_commitments: Option<HashMap<String, [u32; DIGEST_SIZE]>>,
) -> Result<()> {
    println!("{LOG_PREFIX} === Stage 4: Dumping VK JSON ===");

    // Only dump VKs when both exe_commitments and leaf_commitments are available
    if let (Some(exe_commitments), Some(leaf_commitments)) = (&exe_commitments, &leaf_commitments) {
        #[derive(Default, Debug, serde::Serialize)]
        struct VKDump {
            pub chunk_vk: String,
            pub batch_vk: String,
            pub bundle_vk: String,
        }
        let [chunk_vk, batch_vk, bundle_vk] = ["chunk", "batch", "bundle"].map(|circuit| {
            if let (Some(exe), Some(leaf)) =
                (exe_commitments.get(circuit), leaf_commitments.get(circuit))
            {
                let app_vk = scroll_zkvm_types::types_agg::ProgramCommitment {
                    exe: *exe,
                    leaf: *leaf,
                }
                .serialize();

                use base64::{Engine, prelude::BASE64_STANDARD};
                let app_vk = BASE64_STANDARD.encode(app_vk);
                println!("{circuit}: {app_vk}");
                app_vk
            } else {
                String::new() // Empty string for circuits that weren't built
            }
        });

        let dump = VKDump {
            chunk_vk,
            batch_vk,
            bundle_vk,
        };

        let f = std::fs::File::create("openVmVk.json")?;
        serde_json::to_writer(f, &dump)?;
        println!(
            "{LOG_PREFIX} openVmVk.json: {}",
            serde_json::to_string_pretty(&dump)?
        );
        println!("{LOG_PREFIX} VK data written to openVmVk.json");
    }
    Ok(())
}

pub fn main() -> Result<()> {
    // Set current directory to the crate's root
    let manifest_dir = env::var("CARGO_MANIFEST_DIR")?;
    env::set_current_dir(&manifest_dir)?;
    println!("{LOG_PREFIX} Running in directory: {}", manifest_dir);

    // Load .env file if present
    dotenv().ok();

    // Determine workspace root
    let metadata = cargo_metadata::MetadataCommand::new().exec()?;
    let workspace_dir = metadata.workspace_root.into_std_path_buf();
    println!("{LOG_PREFIX} Workspace root: {}", workspace_dir.display());

    // Determine which projects to build
    let projects_to_build_str = env::var("BUILD_PROJECT");
    let projects_to_build = projects_to_build_str
        .as_ref()
        .map(|s| s.split(',').filter(|p| !p.is_empty()).collect::<Vec<_>>())
        .unwrap_or_else(|_| vec!["chunk", "batch", "bundle"]); // Default projects

    if projects_to_build.is_empty() {
        println!("{LOG_PREFIX} No projects specified in BUILD_PROJECT. Exiting.");
        return Ok(());
    }
    println!("{LOG_PREFIX} Projects to build: {:?}", projects_to_build);

    // Determine which stages to run
    let stages_env =
        env::var("BUILD_STAGES").unwrap_or_else(|_| "stage1,stage2,stage3".to_string());
    let stages_to_run: HashSet<&str> = if stages_env.trim().is_empty() {
        // If empty string is provided, run all stages
        ["stage1", "stage2", "stage3"].iter().cloned().collect()
    } else {
        stages_env.split(',').filter(|s| !s.is_empty()).collect()
    };

    if stages_to_run.is_empty() {
        println!("{LOG_PREFIX} No stages specified in BUILD_STAGES. Exiting.");
        return Ok(());
    }
    println!("{LOG_PREFIX} Stages to run: {:?}", stages_to_run);

    // Execute selected stages
    let leaf_commitments = if stages_to_run.contains("stage1") {
        Some(run_stage1_leaf_commitments(
            &projects_to_build,
            &workspace_dir,
        )?)
    } else {
        println!("{LOG_PREFIX} Skipping Stage 1: Leaf Commitments");
        None
    };

    if stages_to_run.contains("stage2") {
        run_stage2_root_verifier(&projects_to_build, &workspace_dir)?;
    } else {
        println!("{LOG_PREFIX} Skipping Stage 2: Root Verifier");
    };

    let exe_commitments = if stages_to_run.contains("stage3") {
        Some(run_stage3_exe_commits(&projects_to_build, &workspace_dir)?)
    } else {
        println!("{LOG_PREFIX} Skipping Stage 3: Exe Commits");
        None
    };

    run_stage4_dump_vk_json(leaf_commitments, exe_commitments)?;

    println!("{LOG_PREFIX} Build process completed successfully.");
    Ok(())
}
