#![allow(clippy::ptr_arg)]
//! Build script for guest circuits (chunk, batch, bundle).
//!
//! This script handles several stages:
//! 1. Generating leaf commitments for circuit verifiers.
//! 2. Generating the root verifier assembly code (if batch or bundle is built).
//! 3. Building guest programs (ELF), transpiling them to VM executables (.vmexe),
//!    and generating executable commitments.
//!
//! Environment variables control behavior:
//! - `BUILD_PROJECT`: Comma-separated list of projects to build (e.g., "chunk,batch"). Defaults to "chunk,batch,bundle".
//! - `BUILD_STAGES`: Comma-separated list of stages to run (e.g., "stage1,stage3"). Defaults to "stage1,stage2,stage3".

use std::{
    collections::{BTreeSet, HashMap}, env, fs::read_to_string, path::{Path, PathBuf}, sync::Arc, time::Instant
};

use dotenv::dotenv;
use eyre::Result;
use openvm_build::GuestOptions;
use openvm_instructions::exe::VmExe;
use openvm_native_compiler::ir::DIGEST_SIZE;
use openvm_native_recursion::halo2::utils::{CacheHalo2ParamsReader, Halo2ParamsReader};
use openvm_sdk::{
    commit::CommitBytes, config::{AggregationConfig, AppConfig, SdkVmConfig}, fs::write_object_to_file, keygen::AggProvingKey, DefaultStaticVerifierPvHandler, Sdk, F
};
use openvm_stark_sdk::{openvm_stark_backend::p3_field::PrimeField32, p3_bn254_fr::Bn254Fr};
use snark_verifier_sdk::snark_verifier::loader::evm::compile_solidity;

const LOG_PREFIX: &str = "[build-guest]";

/// File descriptor for app openvm config.
const FD_APP_CONFIG: &str = "openvm.toml";

/// Writes a commitment array to a Rust source file.
fn write_commitment(output_path: &PathBuf, commitment: [u32; DIGEST_SIZE]) -> Result<()> {
    let content = format!(
        "#![cfg_attr(rustfmt, rustfmt_skip)]\n//! Generated by crates/build-guest. DO NOT EDIT!\n\npub const COMMIT: [u32; {DIGEST_SIZE}] = {commitment:?};\n"
    );
    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    std::fs::write(output_path, content)?;
    println!("{LOG_PREFIX} Wrote commitment to {}", output_path.display());
    Ok(())
}

/// Writes a commitment array as hex
fn write_commitment_as_evm_hex(
    output_path: &PathBuf,
    commitment: [u32; DIGEST_SIZE],
) -> Result<()> {
    let digest_bytes = compress_commitment(&commitment)
        .value
        .to_bytes()
        .into_iter()
        .rev() // To big endian
        .collect::<Vec<u8>>();
    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    std::fs::write(output_path, hex::encode(digest_bytes))?;
    println!("{LOG_PREFIX} Wrote commitment to {}", output_path.display());
    Ok(())
}
/// Compresses an 8-element u32 commitment into a single Fr element.
/// Used for generating digests compatible with on-chain verifiers.
fn compress_commitment(commitment: &[u32; DIGEST_SIZE]) -> Bn254Fr {
    CommitBytes::from_u32_digest(commitment).to_bn254()
}

/// Stage 1: Generates and writes leaf commitments for each specified project.
fn run_stage1_leaf_commitments(
    project_names: &[&str],
    workspace_dir: &Path,
    release_output_dir: &PathBuf,
) -> Result<HashMap<String, [u32; DIGEST_SIZE]>> {
    println!("{LOG_PREFIX} === Stage 1: Generating Leaf Commitments ===");
    let mut leaf_commitments = HashMap::new();
    for &project_name in project_names {
        println!("{LOG_PREFIX} Processing project: {project_name}");
        let project_dir = workspace_dir
            .join("crates")
            .join("circuits")
            .join(format!("{project_name}-circuit"));
        let path_app_config = Path::new(&project_dir).join(FD_APP_CONFIG);
        let app_config: AppConfig<SdkVmConfig> =
            toml::from_str(&read_to_string(&path_app_config).unwrap()).unwrap();

        // Generate vm commitment
        let sdk = Sdk::new(app_config.clone())?;
        let leaf_vm_verifier_commit_f: [F; DIGEST_SIZE] =
            sdk.app_pk().leaf_committed_exe.get_program_commit().into();
        let leaf_vm_verifier_commit_u32 = leaf_vm_verifier_commit_f.map(|f| f.as_canonical_u32());
        leaf_commitments.insert(project_name.to_string(), leaf_vm_verifier_commit_u32);

        // Write the commitment to a .rs file
        let output_path = project_dir.join(format!("{project_name}_leaf_commit.rs"));
        write_commitment(&output_path, leaf_vm_verifier_commit_u32)?;

        // Special handling for bundle project: generate digest_2
        if project_name == "bundle" {
            println!("{LOG_PREFIX} Generating digest_2 for bundle project...");
            let output_path = release_output_dir.join(project_name).join("digest_2.hex");
            write_commitment_as_evm_hex(&output_path, leaf_vm_verifier_commit_u32)?;
        }
    }
    println!("{LOG_PREFIX} === Stage 1 Finished ===");
    Ok(leaf_commitments)
}

/// Stage 2: Generates the root verifier assembly code.
fn run_stage2_root_verifier(project_names: &[&str], workspace_dir: &Path) -> Result<()> {
    println!("{LOG_PREFIX} === Stage 2: Generating Root Verifier ===");
    // Only generate if "batch" or "bundle" is being built, as they use recursive verification.
    if project_names
        .iter()
        .any(|&name| name == "batch" || name == "bundle")
    {
        println!("{LOG_PREFIX} Generating root verifier assembly...");
        let root_verifier_path = workspace_dir
            .join("crates")
            .join("build-guest")
            .join("root_verifier.asm");

        println!("generating root_verifier.asm");
        let asm = openvm_sdk::Sdk::riscv32().generate_root_verifier_asm();
        std::fs::write(&root_verifier_path, asm).expect("fail to write");

        println!(
            "{LOG_PREFIX} Root verifier generated at: {}",
            root_verifier_path.display()
        );
    } else {
        println!(
            "{LOG_PREFIX} Skipping root verifier generation (not needed for selected projects)."
        );
    }
    println!("{LOG_PREFIX} === Stage 2 Finished ===");
    Ok(())
}

/// Stage 3: Builds guest programs, transpiles them, and generates executable commitments.
fn run_stage3_exe_commits(
    project_names: &[&str],
    workspace_dir: &Path,
    release_output_dir: &PathBuf,
) -> Result<HashMap<String, [u32; DIGEST_SIZE]>> {
    println!("{LOG_PREFIX} === Stage 3: Generating Executable Commitments ===");
    let mut exe_commitments = HashMap::new();
    for &project_name in project_names {
        let project_path = workspace_dir
            .join("crates")
            .join("circuits")
            .join(format!("{project_name}-circuit"));

        println!("{LOG_PREFIX} Processing project: {project_name}");

        let start_time = Instant::now();
        println!("{LOG_PREFIX} Starting build...");

        let project_dir = project_path.to_str().expect("Invalid path");
        // First read the app config specified in the project's root directory.
        let path_app_config = Path::new(project_dir).join(FD_APP_CONFIG);
        let app_config: AppConfig<SdkVmConfig> =
            toml::from_str(&read_to_string(&path_app_config).unwrap()).unwrap();
        println!(
            "{project_dir} app config: {}",
            toml::to_string_pretty(&app_config).unwrap()
        );

        // copy path_app_config as ${release_output_dir}/${project_name}/${FD_APP_CONFIG}
        let output_path = release_output_dir.join(project_name).join(FD_APP_CONFIG);
        if let Some(parent) = output_path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        std::fs::copy(&path_app_config, &output_path)?;
        println!("{LOG_PREFIX} Copied config to {}", output_path.display());

        // 1. Build ELF

        // Store current directory and change to project directory
        let original_dir = env::current_dir()?;
        env::set_current_dir(&project_path)?;
        println!(
            "{LOG_PREFIX} Changed working directory to: {}",
            project_path.display()
        );
        let guest_opts = GuestOptions::default();
        let guest_opts = guest_opts.with_profile("maxperf".to_string());
        let sdk = Sdk::new(app_config)?;
        let elf = sdk
            .build(
                guest_opts,
                project_dir,
                &Default::default(),
                None,
            )
            .inspect_err(|_err| {
                println!("{LOG_PREFIX} Building failed in {}", project_dir);
            })?;
        println!("{LOG_PREFIX} Built ELF");

        // Revert to original directory
        env::set_current_dir(&original_dir)?;
        println!(
            "{LOG_PREFIX} Reverted working directory to: {}",
            original_dir.display()
        );

        // 2. Transpile ELF to VM Executable
        let app_exe: VmExe<F> = (*sdk.convert_to_exe(elf)?).clone();

        // Create the assets dir if not already present.
        let path_assets = Path::new(release_output_dir).join(project_name);
        std::fs::create_dir_all(&path_assets)?;
        // Write exe to disc.
        let path_app_exe: PathBuf = path_assets.join("app.vmexe");
        write_object_to_file(&path_app_exe, app_exe.clone())?;

        //println!("{LOG_PREFIX} exe written to {path_app_exe:?}");

        // 3. Compute and Write Executable Commitment
        let prover = sdk.prover(app_exe)?;
        let exe_commit_u32 = prover.app_commit().app_exe_commit.to_u32_digest();
        exe_commitments.insert(project_name.to_string(), exe_commit_u32);

        let commit_filename = format!("{project_name}_exe_commit.rs");

        let output_path = Path::new(project_dir).join(&commit_filename);
        write_commitment(&output_path, exe_commit_u32)?;

        // Special handling for bundle project: generate digest_1
        if project_name == "bundle" {
            println!("{LOG_PREFIX} Generating digest_1 for bundle project...",);
            let output_path = release_output_dir.join(project_name).join("digest_1.hex");
            write_commitment_as_evm_hex(&output_path, exe_commit_u32)?;
        }

        println!(
            "{LOG_PREFIX} Finished build for config in {:?}",
            start_time.elapsed()
        );
    }
    println!("{LOG_PREFIX} === Stage 3 Finished ===");
    Ok(exe_commitments)
}

/// Stage 4: Dumps VK data to a JSON file if both exe and leaf commitments are available.
fn run_stage4_dump_vk_json(
    release_output_dir: &PathBuf,
    leaf_commitments: Option<HashMap<String, [u32; DIGEST_SIZE]>>,
    exe_commitments: Option<HashMap<String, [u32; DIGEST_SIZE]>>,
) -> Result<()> {
    println!("{LOG_PREFIX} === Stage 4: Dumping VK JSON ===");

    // Only dump VKs when both exe_commitments and leaf_commitments are available
    if let (Some(exe_commitments), Some(leaf_commitments)) = (&exe_commitments, &leaf_commitments) {
        #[derive(Default, Debug, serde::Serialize)]
        struct VKDump {
            pub chunk_vk: String,
            pub batch_vk: String,
            pub bundle_vk: String,
        }
        let [chunk_vk, batch_vk, bundle_vk] = ["chunk", "batch", "bundle"].map(|circuit| {
            if let (Some(exe), Some(leaf)) =
                (exe_commitments.get(circuit), leaf_commitments.get(circuit))
            {
                let app_vk = scroll_zkvm_types::types_agg::ProgramCommitment {
                    exe: *exe,
                    vm: *leaf,
                }
                .serialize();

                use base64::{Engine, prelude::BASE64_STANDARD};
                let app_vk = BASE64_STANDARD.encode(app_vk);
                println!("{circuit}: {app_vk}");
                app_vk
            } else {
                String::new() // Empty string for circuits that weren't built
            }
        });

        let dump = VKDump {
            chunk_vk,
            batch_vk,
            bundle_vk,
        };

        let output_path = release_output_dir.join("verifier").join("openVmVk.json");
        if let Some(parent) = output_path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        let f = std::fs::File::create(output_path)?;
        serde_json::to_writer(f, &dump)?;
        println!(
            "{LOG_PREFIX} openVmVk.json: {}",
            serde_json::to_string_pretty(&dump)?
        );
        println!("{LOG_PREFIX} VK data written to openVmVk.json");
    }
    Ok(())
}

fn run_stage5_dump_evm_verifier(verifier_output_dir: &PathBuf, recompute_mode: bool) -> Result<()> {
    println!("{LOG_PREFIX} === Stage 5: Dumping EVM VERIFIER ===");
    let path_verifier_sol = verifier_output_dir.join("verifier.sol");
    let path_verifier_bin = verifier_output_dir.join("verifier.bin");
    if let Some(parent) = path_verifier_bin.parent() {
        std::fs::create_dir_all(parent)?;
    }
    let verifier_contract = if recompute_mode {
        let sdk = Sdk::riscv32();
        let halo2_params_reader = sdk.halo2_params_reader();
        let halo2_pk = sdk.halo2_pk(
        );
        let halo2_params = halo2_params_reader
            .read_params(halo2_pk.wrapper.pinning.metadata.config_params.k);
        snark_verifier_sdk::evm::gen_evm_verifier_shplonk::<
            snark_verifier_sdk::halo2::aggregation::AggregationCircuit,
        >(
            &halo2_params,
            halo2_pk.wrapper.pinning.pk.get_vk(),
            halo2_pk.wrapper.pinning.metadata.num_pvs.clone(),
            Some(&path_verifier_sol),
        )
    } else {
        println!("{LOG_PREFIX} Downloading pre-built verifier from openvm-solidity-sdk...");
        let verifier_url = "https://github.com/openvm-org/openvm-solidity-sdk/raw/refs/heads/main/src/v1.3/Halo2Verifier.sol";

        let output = std::process::Command::new("wget")
            .arg("-q")
            .arg("-O")
            .arg("-")
            .arg(verifier_url)
            .output()?;

        if !output.status.success() {
            return Err(eyre::eyre!(
                "Failed to download verifier from {}: wget exited with code {:?}",
                verifier_url,
                output.status.code()
            ));
        }

        let sol_code = String::from_utf8(output.stdout)?;
        std::fs::write(&path_verifier_sol, &sol_code)?;
        println!(
            "{LOG_PREFIX} Downloaded verifier.sol to {}",
            path_verifier_sol.display()
        );

        compile_solidity(&sol_code)
    };
    std::fs::write(&path_verifier_bin, &verifier_contract)?;
    println!("{LOG_PREFIX} verifier_contract written to {path_verifier_bin:?}");

    println!("{LOG_PREFIX} === Stage 5 Finished ===");
    Ok(())
}

pub fn main() -> Result<()> {
    // Set current directory to the crate's root
    let manifest_dir = env::var("CARGO_MANIFEST_DIR")?;
    env::set_current_dir(&manifest_dir)?;
    println!("{LOG_PREFIX} Running in directory: {}", manifest_dir);

    // Load .env file if present
    dotenv().ok();

    // Determine workspace root
    let metadata = cargo_metadata::MetadataCommand::new().exec()?;
    let workspace_dir = metadata.workspace_root.into_std_path_buf();
    println!("{LOG_PREFIX} Workspace root: {}", workspace_dir.display());

    let release_output_dir: std::path::PathBuf = workspace_dir.join("releases").join("dev");
    std::fs::create_dir_all(&release_output_dir)?;
    println!(
        "{LOG_PREFIX} Release output directory: {}",
        release_output_dir.display()
    );

    // Determine which projects to build
    let projects_to_build_str = env::var("BUILD_PROJECT");
    let projects_to_build = projects_to_build_str
        .as_ref()
        .map(|s| s.split(',').filter(|p| !p.is_empty()).collect::<Vec<_>>())
        .unwrap_or_else(|_| vec!["chunk", "batch", "bundle"]); // Default projects

    if projects_to_build.is_empty() {
        println!("{LOG_PREFIX} No projects specified in BUILD_PROJECT. Exiting.");
        return Ok(());
    }
    println!("{LOG_PREFIX} Projects to build: {:?}", projects_to_build);

    // Determine which stages to run
    let stages_env =
        env::var("BUILD_STAGES").unwrap_or_else(|_| "stage1,stage2,stage3".to_string());
    let stages_to_run: BTreeSet<&str> = if stages_env.trim().is_empty() {
        // If empty string is provided, run all stages
        ["stage1", "stage2", "stage3"].iter().cloned().collect()
    } else {
        stages_env.split(',').filter(|s| !s.is_empty()).collect()
    };

    if stages_to_run.is_empty() {
        println!("{LOG_PREFIX} No stages specified in BUILD_STAGES. Exiting.");
        return Ok(());
    }
    println!("{LOG_PREFIX} Stages to run: {:?}", stages_to_run);

    // Execute selected stages
    let leaf_commitments = if stages_to_run.contains("stage1") {
        Some(run_stage1_leaf_commitments(
            &projects_to_build,
            &workspace_dir,
            &release_output_dir,
        )?)
    } else {
        println!("{LOG_PREFIX} Skipping Stage 1: Leaf Commitments");
        None
    };

    if stages_to_run.contains("stage2") {
        run_stage2_root_verifier(&projects_to_build, &workspace_dir)?;
    } else {
        println!("{LOG_PREFIX} Skipping Stage 2: Root Verifier");
    };

    let exe_commitments = if stages_to_run.contains("stage3") {
        Some(run_stage3_exe_commits(
            &projects_to_build,
            &workspace_dir,
            &release_output_dir,
        )?)
    } else {
        println!("{LOG_PREFIX} Skipping Stage 3: Exe Commits");
        None
    };

    run_stage4_dump_vk_json(&release_output_dir, leaf_commitments, exe_commitments)?;

    run_stage5_dump_evm_verifier(
        &release_output_dir.join("verifier"),
        stages_to_run.contains("stage5"),
    )?;

    println!("{LOG_PREFIX} Build process completed successfully.");
    Ok(())
}

/*
/// Wrapper around [`openvm_sdk::fs::read_exe_from_file`].
pub fn read_app_exe<P: AsRef<Path>>(path: P) -> Result<VmExe<F>, eyre::Error> {


    /// Executable program for OpenVM.
    #[derive(Clone, Debug, Default, serde::Serialize, serde::Deserialize)]
    #[serde(bound(
        serialize = "F: serde::Serialize",
        deserialize = "F: std::cmp::Ord + serde::Deserialize<'de>"
    ))]
    pub struct OldVmExe<F> {
        /// Program to execute.
        pub program: Program<F>,
        /// Start address of pc.
        pub pc_start: u32,
        /// Initial memory image.
        pub init_memory: BTreeMap<(u32, u32), F>,
        /// Starting + ending bounds for each function.
        pub fn_bounds: FnBounds,
    }

    let exe: OldVmExe<F> = read_from_file_bitcode(&path).unwrap();
    use openvm_stark_sdk::openvm_stark_backend::p3_field::FieldAlgebra;
    use openvm_stark_sdk::openvm_stark_backend::p3_field::PrimeField32;
    let exe = VmExe::<F> {
        program: exe.program,
        pc_start: exe.pc_start,
        init_memory: exe.init_memory.into_iter().map(|(k, v)| {
         assert!(v < F::from_canonical_u32(256u32));
         (k, v.as_canonical_u32() as u8)
        }).collect(),
        fn_bounds: exe.fn_bounds,
    };
    Ok(exe)
}
    */
