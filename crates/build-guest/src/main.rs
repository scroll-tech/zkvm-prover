//! Build script for guest circuits (chunk, batch, bundle).
//!
//! This script handles several stages:
//! 1. Generating leaf commitments for circuit verifiers.
//! 2. Generating the root verifier assembly code (if batch or bundle is built).
//! 3. Building guest programs (ELF), transpiling them to VM executables (.vmexe),
//!    and generating executable commitments.
//!
//! Environment variables control behavior:
//! - `BUILD_PROJECT`: Comma-separated list of projects to build (e.g., "chunk,batch"). Defaults to "chunk,batch,bundle".
//! - `BUILD_STAGES`: Comma-separated list of stages to run (e.g., "stage1,stage3"). Defaults to "stage1,stage2,stage3".

use std::{collections::HashSet, env, path::Path, time::Instant};

use dotenv::dotenv;
use eyre::Result; // Use eyre::Result directly
use openvm_native_compiler::ir::DIGEST_SIZE;
use openvm_sdk::{config::SdkVmConfig, Sdk, F};
use openvm_stark_sdk::{openvm_stark_backend::p3_field::PrimeField32, p3_baby_bear::BabyBear};
use snark_verifier_sdk::snark_verifier::loader::halo2::halo2_ecc::halo2_base::halo2_proofs::halo2curves::bn256::Fr;

mod verifier;
use verifier::dump_verifier;

mod builder;

const LOG_PREFIX: &str = "[build-guest]";

/// Writes a commitment array to a Rust source file.
fn write_commitment(output_path: &str, commitment: [u32; DIGEST_SIZE]) -> Result<()> {
    let content = format!(
        "#![cfg_attr(rustfmt, rustfmt_skip)]\n//! Generated by crates/build-guest. DO NOT EDIT!\n\npub const COMMIT: [u32; {DIGEST_SIZE}] = {commitment:?};\n"
    );
    std::fs::write(output_path, content)?;
    println!("{LOG_PREFIX} Wrote commitment to {output_path}");
    Ok(())
}

/// Compresses an 8-element u32 commitment into a single Fr element.
/// Used for generating digests compatible with on-chain verifiers.
fn compress_commitment(commitment: &[u32; DIGEST_SIZE]) -> Fr {
    // Ensure DIGEST_SIZE is 8 for this specific compression logic
    assert_eq!(
        DIGEST_SIZE, 8,
        "compress_commitment assumes DIGEST_SIZE is 8"
    );
    let order = Fr::from(BabyBear::ORDER_U32 as u64);
    let mut base = Fr::one();
    let mut compressed_value = Fr::zero();

    for val in commitment {
        compressed_value += Fr::from(*val as u64) * base;
        base *= order;
    }

    compressed_value
}

/// Configuration for building a specific variant of a guest program.
#[derive(Debug)]
pub(crate) struct BuildConfig {
    /// Cargo features to enable for this build.
    pub(crate) features: Vec<String>,
    /// Suffix to append to generated filenames (e.g., "_rv32"). Empty string for default.
    pub(crate) filename_suffix: String,
}

/// Returns the build configurations for a given project name.
fn get_build_configs(project_name: &str) -> Vec<BuildConfig> {
    match project_name {
        "chunk" => vec![
            BuildConfig {
                features: vec![],
                filename_suffix: "_rv32".to_string(), // Suffix for the RV32 variant
            },
            BuildConfig {
                features: vec!["openvm".to_string()],
                filename_suffix: "".to_string(), // No suffix for the default (OpenVM) variant
            },
        ],
        "batch" => vec![BuildConfig {
            features: vec![],
            filename_suffix: "".to_string(),
        }],
        "bundle" => vec![
            BuildConfig {
                features: vec![],
                filename_suffix: "_euclidv1".to_string(), // Suffix for Euclid v1
            },
            BuildConfig {
                features: vec!["euclidv2".to_string()],
                filename_suffix: "".to_string(), // No suffix for the default (Euclid v2)
            },
        ],
        _ => {
            // Use panic instead of unreachable for build scripts, providing a clearer error.
            panic!("{LOG_PREFIX} Unsupported project name: {project_name}");
        }
    }
}

/// Generates the root verifier assembly code if required by the selected projects.
fn generate_root_verifier(project_names: &[&str], workspace_dir: &Path) -> Result<()> {
    // Only generate if "batch" or "bundle" is being built, as they use recursive verification.
    if project_names
        .iter()
        .any(|&name| name == "batch" || name == "bundle")
    {
        println!("{LOG_PREFIX} Generating root verifier assembly...");
        let root_verifier_path = workspace_dir
            .join("crates")
            .join("build-guest")
            .join("root_verifier.asm");
        dump_verifier(root_verifier_path.to_str().expect("Invalid path")); // Use expect for build script paths
        println!(
            "{LOG_PREFIX} Root verifier generated at: {}",
            root_verifier_path.display()
        );
    } else {
        println!(
            "{LOG_PREFIX} Skipping root verifier generation (not needed for selected projects)."
        );
    }
    Ok(())
}

/// Stage 1: Generates and writes leaf commitments for each specified project.
fn run_stage1_leaf_commitments(project_names: &[&str], workspace_dir: &Path) -> Result<()> {
    println!("{LOG_PREFIX} === Stage 1: Generating Leaf Commitments ===");
    for &project_name in project_names {
        println!("{LOG_PREFIX} Processing project: {project_name}");
        let project_dir = workspace_dir
            .join("crates")
            .join("circuits")
            .join(format!("{project_name}-circuit"));
        let app_config = builder::load_app_config(project_dir.to_str().expect("Invalid path"))?;

        // Generate public key (which includes leaf commitment)
        let app_pk = Sdk::new().app_keygen(app_config.clone())?;
        let leaf_vm_verifier_commit_f: [F; DIGEST_SIZE] = app_pk
            .leaf_committed_exe
            .committed_program
            .commitment
            .into();
        let leaf_vm_verifier_commit_u32 = leaf_vm_verifier_commit_f.map(|f| f.as_canonical_u32());

        // Write the commitment to a .rs file
        let output_path = project_dir.join(format!("{project_name}_leaf_commit.rs"));
        write_commitment(
            output_path.to_str().expect("Invalid path"),
            leaf_vm_verifier_commit_u32,
        )?;

        // Special handling for bundle project: generate digest_2
        if project_name == "bundle" {
            println!("{LOG_PREFIX} Generating digest_2 for bundle project...");
            let digest_2_bytes = compress_commitment(&leaf_vm_verifier_commit_u32)
                .to_bytes()
                .into_iter()
                .rev() // Ensure correct byte order if needed (verify endianness requirement)
                .collect::<Vec<u8>>();
            let digest_2_path = project_dir.join("digest_2");
            std::fs::write(&digest_2_path, &digest_2_bytes)?;
            println!("{LOG_PREFIX} Wrote digest_2 to {}", digest_2_path.display());
        }
    }
    println!("{LOG_PREFIX} === Stage 1 Finished ===");
    Ok(())
}

/// Stage 2: Generates the root verifier assembly code.
fn run_stage2_root_verifier(project_names: &[&str], workspace_dir: &Path) -> Result<()> {
    println!("{LOG_PREFIX} === Stage 2: Generating Root Verifier ===");
    generate_root_verifier(project_names, workspace_dir)?;
    println!("{LOG_PREFIX} === Stage 2 Finished ===");
    Ok(())
}

/// Stage 3: Builds guest programs, transpiles them, and generates executable commitments.
fn run_stage3_exe_commits(project_names: &[&str], workspace_dir: &Path) -> Result<()> {
    println!("{LOG_PREFIX} === Stage 3: Generating Executable Commitments ===");
    for &project_name in project_names {
        let project_dir = workspace_dir
            .join("crates")
            .join("circuits")
            .join(format!("{project_name}-circuit"));
        let build_configs = get_build_configs(project_name);

        println!(
            "{LOG_PREFIX} Processing project: {project_name} ({} build configs)",
            build_configs.len()
        );

        for build_config in build_configs {
            let start_time = Instant::now();
            println!("{LOG_PREFIX} Starting build for config: {build_config:?}...");

            let project_dir = project_dir.to_str().expect("Invalid path");
            let app_config = builder::load_app_config(&project_dir)?;

            // 1. Build ELF
            let elf = builder::build(&project_dir, &build_config.features)?;
            println!("{LOG_PREFIX} Built ELF");

            // 2. Transpile ELF to VM Executable
            let vmexe_filename = format!("app{}.vmexe", build_config.filename_suffix);
            let app_exe = builder::transpile(
                &project_dir,
                elf,
                Some(&vmexe_filename), // Pass filename directly
                app_config.clone(),
            )?;
            println!("{LOG_PREFIX} Transpiled to VM Executable: {vmexe_filename}");

            // 3. Commit VM Executable
            let app_committed_exe =
                Sdk::new().commit_app_exe(app_config.app_fri_params.fri_params, app_exe)?;

            // 4. Compute and Write Executable Commitment
            use openvm_circuit::arch::VmConfig;
            let exe_commit_f: [F; DIGEST_SIZE] = app_committed_exe
                .compute_exe_commit(
                    &<SdkVmConfig as VmConfig<F>>::system(&app_config.app_vm_config).memory_config,
                )
                .into();
            let exe_commit_u32: [u32; DIGEST_SIZE] = exe_commit_f.map(|f| f.as_canonical_u32());

            let commit_filename = format!(
                "{project_name}_exe{}_commit.rs",
                build_config.filename_suffix
            );
            let output_path = Path::new(project_dir).join(&commit_filename);
            write_commitment(output_path.to_str().expect("Invalid path"), exe_commit_u32)?;

            // Special handling for bundle project: generate digest_1
            if project_name == "bundle" {
                println!(
                    "{LOG_PREFIX} Generating digest_1{} for bundle project...",
                    build_config.filename_suffix
                );
                let digest_1_bytes = compress_commitment(&exe_commit_u32)
                    .to_bytes()
                    .into_iter()
                    .rev() // Ensure correct byte order
                    .collect::<Vec<u8>>();
                let digest_1_filename = format!("digest_1{}", build_config.filename_suffix,);
                let digest_1_path = Path::new(project_dir).join(&digest_1_filename);
                std::fs::write(&digest_1_path, &digest_1_bytes)?;
                println!(
                    "{LOG_PREFIX} Wrote {} to {}",
                    digest_1_filename,
                    digest_1_path.display()
                );
            }

            println!(
                "{LOG_PREFIX} Finished build for config: {:?} in {:?}",
                build_config,
                start_time.elapsed()
            );
        }
    }
    println!("{LOG_PREFIX} === Stage 3 Finished ===");
    Ok(())
}

pub fn main() -> Result<()> {
    // Load .env file if present
    dotenv().ok();

    // Set current directory to the crate's root
    let manifest_dir = env::var("CARGO_MANIFEST_DIR")?;
    env::set_current_dir(&manifest_dir)?;
    println!("{LOG_PREFIX} Running in directory: {}", manifest_dir);

    // Determine workspace root
    let metadata = cargo_metadata::MetadataCommand::new().exec()?;
    let workspace_dir = metadata.workspace_root.into_std_path_buf();
    println!("{LOG_PREFIX} Workspace root: {}", workspace_dir.display());

    // Determine which projects to build
    let projects_to_build_str = env::var("BUILD_PROJECT");
    let projects_to_build = projects_to_build_str
        .as_ref()
        .map(|s| s.split(',').filter(|p| !p.is_empty()).collect::<Vec<_>>())
        .unwrap_or_else(|_| vec!["chunk", "batch", "bundle"]); // Default projects

    if projects_to_build.is_empty() {
        println!("{LOG_PREFIX} No projects specified in BUILD_PROJECT. Exiting.");
        return Ok(());
    }
    println!("{LOG_PREFIX} Projects to build: {:?}", projects_to_build);

    // Determine which stages to run
    let stages_env =
        env::var("BUILD_STAGES").unwrap_or_else(|_| "stage1,stage2,stage3".to_string());
    let stages_to_run: HashSet<&str> = if stages_env.trim().is_empty() {
        // If empty string is provided, run all stages
        ["stage1", "stage2", "stage3"].iter().cloned().collect()
    } else {
        stages_env.split(',').filter(|s| !s.is_empty()).collect()
    };

    if stages_to_run.is_empty() {
        println!("{LOG_PREFIX} No stages specified in BUILD_STAGES. Exiting.");
        return Ok(());
    }
    println!("{LOG_PREFIX} Stages to run: {:?}", stages_to_run);

    // Execute selected stages
    if stages_to_run.contains("stage1") {
        run_stage1_leaf_commitments(&projects_to_build, &workspace_dir)?;
    } else {
        println!("{LOG_PREFIX} Skipping Stage 1: Leaf Commitments");
    }

    if stages_to_run.contains("stage2") {
        run_stage2_root_verifier(&projects_to_build, &workspace_dir)?;
    } else {
        println!("{LOG_PREFIX} Skipping Stage 2: Root Verifier");
    }

    if stages_to_run.contains("stage3") {
        run_stage3_exe_commits(&projects_to_build, &workspace_dir)?;
    } else {
        println!("{LOG_PREFIX} Skipping Stage 3: Exe Commits");
    }

    println!("{LOG_PREFIX} Build process completed successfully.");
    Ok(())
}
