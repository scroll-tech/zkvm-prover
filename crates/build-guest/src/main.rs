#![allow(clippy::ptr_arg)]
//! Build script for guest circuits (chunk, batch, bundle).
//!
//! This script builds OpenVM guest programs and generates associated assets:
//!
//! ## App Assets Generation:
//! 1. Builds guest programs (ELF) for specified projects
//! 2. Transpiles ELF files to VM executables (.vmexe)
//! 3. Generates executable and VM commitments
//! 4. Creates verification keys and supporting files
//!
//! ## OpenVM Assets Generation:
//! 1. Generates root verifier assembly code
//! 2. Creates EVM verifier contract (Solidity) and bytecode
//!
//! ## Usage:
//! ```bash
//! cargo run --bin build-guest [OPTIONS]
//! ```
//!
//! ## Options:
//! - `--mode <MODE>`: Generation mode (auto|force)
//!   - `auto`: Skip generation if output files already exist (default, faster for development)
//!   - `force`: Always regenerate all files (use for clean builds or CI)
//!
//! ## Environment Variables:
//! - `BUILD_PROJECT`: Comma-separated list of projects to build (e.g., "chunk,batch").
//!   Defaults to "chunk,batch,bundle".
//!
//! ## Output:
//! - App assets: `releases/dev/{project_name}/`
//! - OpenVM assets: `releases/dev/verifier/`
//! - Commitment files: Written to respective circuit crate directories

use std::{
    env,
    fs::read_to_string,
    path::{Path, PathBuf},
    sync::Arc,
    time::Instant,
};

use clap::{Parser, ValueEnum};
use dotenv::dotenv;
use eyre::Result;
use openvm_build::GuestOptions;
use openvm_instructions::exe::VmExe;
use openvm_native_compiler::ir::DIGEST_SIZE;
use openvm_sdk::{
    F, Sdk,
    commit::CommitBytes,
    config::{AppConfig, SdkVmConfig},
    fs::write_object_to_file,
    prover::AppProver,
};
use openvm_stark_sdk::p3_bn254_fr::Bn254Fr;
use snark_verifier_sdk::snark_verifier::loader::evm::compile_solidity;

mod verifier;

#[derive(Debug, Clone, ValueEnum)]
enum OutputMode {
    /// Skip generation when output file already exists (default)
    Auto,
    /// Always overwrite existing files
    Force,
}

#[derive(Parser)]
#[command(name = "build-guest")]
#[command(about = "Build script for guest circuits (chunk, batch, bundle)")]
struct Cli {
    /// Generation mode for OpenVM assets:
    /// - auto: Skip generation if output files already exist (faster for development)
    /// - force: Always regenerate all files (use for clean builds or CI)
    #[arg(long, value_enum, default_value_t = OutputMode::Auto)]
    mode: OutputMode,

    /// Output directory name under releases/ (default: "dev")
    #[arg(long, default_value = "dev")]
    output: String,
}

const LOG_PREFIX: &str = "[build-guest]";

/// File descriptor for app openvm config.
const FD_APP_CONFIG: &str = "openvm.toml";

/// Writes a commitment array to a Rust source file.
fn write_commitment(output_path: &PathBuf, commitment: [u32; DIGEST_SIZE]) -> Result<()> {
    let content = format!(
        "#![cfg_attr(rustfmt, rustfmt_skip)]\n//! Generated by crates/build-guest. DO NOT EDIT!\n\npub const COMMIT: [u32; {DIGEST_SIZE}] = {commitment:?};\n"
    );
    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    std::fs::write(output_path, content)?;

    println!("{LOG_PREFIX} Wrote commitment to {}", output_path.display());

    Ok(())
}

/// Writes a commitment array as hex
fn write_commitment_as_evm_hex(
    output_path: &PathBuf,
    commitment: [u32; DIGEST_SIZE],
) -> Result<()> {
    let digest_bytes = compress_commitment(&commitment)
        .value
        .to_bytes()
        .into_iter()
        .rev() // To big endian
        .collect::<Vec<u8>>();
    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    std::fs::write(output_path, hex::encode(digest_bytes))?;
    println!("{LOG_PREFIX} Wrote commitment to {}", output_path.display());
    Ok(())
}
/// Compresses an 8-element u32 commitment into a single Fr element.
/// Used for generating digests compatible with on-chain verifiers.
fn compress_commitment(commitment: &[u32; DIGEST_SIZE]) -> Bn254Fr {
    CommitBytes::from_u32_digest(commitment).to_bn254()
}

/// Builds guest programs, transpiles them, and generates executable commitments.
fn generate_app_assets(workspace_dir: &Path, release_output_dir: &PathBuf) -> Result<()> {
    println!("{LOG_PREFIX} === Generating App Assets ===");

    // Determine which projects to build
    let projects_to_build_str = env::var("BUILD_PROJECT");
    let projects_to_build = projects_to_build_str
        .as_ref()
        .map(|s| s.split(',').filter(|p| !p.is_empty()).collect::<Vec<_>>())
        .unwrap_or_else(|_| vec!["chunk", "batch", "bundle"]); // Default projects

    println!("{LOG_PREFIX} Projects to build: {:?}", projects_to_build);

    let mut vk_dump: serde_json::Value = serde_json::from_str("{}").unwrap();
    for project_name in projects_to_build {
        let project_path = workspace_dir
            .join("crates")
            .join("circuits")
            .join(format!("{project_name}-circuit"));

        println!("{LOG_PREFIX} Processing project: {project_name}");

        let start_time = Instant::now();
        println!("{LOG_PREFIX} Starting build...");

        let project_dir = project_path.to_str().expect("Invalid path");
        // First read the app config specified in the project's root directory.
        let path_app_config = Path::new(project_dir).join(FD_APP_CONFIG);
        let app_config: AppConfig<SdkVmConfig> =
            toml::from_str(&read_to_string(&path_app_config).unwrap()).unwrap();
        println!(
            "{project_dir} app config: {}",
            toml::to_string_pretty(&app_config).unwrap()
        );

        // copy path_app_config as ${release_output_dir}/${project_name}/${FD_APP_CONFIG}
        let output_path = release_output_dir.join(project_name).join(FD_APP_CONFIG);
        if let Some(parent) = output_path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        std::fs::copy(&path_app_config, &output_path)?;
        println!("{LOG_PREFIX} Copied config to {}", output_path.display());

        // 1. Build ELF

        // Store current directory and change to project directory
        let original_dir = env::current_dir()?;
        env::set_current_dir(&project_path)?;
        println!(
            "{LOG_PREFIX} Changed working directory to: {}",
            project_path.display()
        );
        let guest_opts = GuestOptions::default();
        let guest_opts = guest_opts.with_profile("maxperf".to_string());
        let sdk = Sdk::new(app_config)?;
        let elf = sdk
            .build(guest_opts, project_dir, &Default::default(), None)
            .inspect_err(|_err| {
                println!("{LOG_PREFIX} Building failed in {}", project_dir);
            })?;
        println!("{LOG_PREFIX} Built ELF");

        // Revert to original directory
        env::set_current_dir(&original_dir)?;
        println!(
            "{LOG_PREFIX} Reverted working directory to: {}",
            original_dir.display()
        );

        // 2. Transpile ELF to VM Executable
        let app_exe: VmExe<F> = (*sdk.convert_to_exe(elf)?).clone();

        // Create the assets dir if not already present.
        let path_assets = Path::new(release_output_dir).join(project_name);
        std::fs::create_dir_all(&path_assets)?;
        // Write exe to disc.
        let path_app_exe: PathBuf = path_assets.join("app.vmexe");
        write_object_to_file(&path_app_exe, app_exe.clone())?;
        println!("{LOG_PREFIX} exe written to {path_app_exe:?}");

        // 3. Compute and Write Executable Commitment
        let app_pk = sdk.app_pk();
        let app_prover: AppProver<openvm_sdk::DefaultStarkEngine, _> = AppProver::new(
            *sdk.app_vm_builder(),
            &app_pk.app_vm_pk,
            Arc::new(app_exe),
            app_pk.leaf_committed_exe.get_program_commit(),
        )?;
        let app_comm = app_prover.app_commit();
        let exe_commit_u32 = app_comm.app_exe_commit.to_u32_digest();
        let vm_commit_u32 = app_comm.app_vm_commit.to_u32_digest();

        write_commitment(
            &Path::new(project_dir).join(format!("{project_name}_exe_commit.rs")),
            exe_commit_u32,
        )?;
        write_commitment(
            &Path::new(project_dir).join(format!("{project_name}_vm_commit.rs")),
            vm_commit_u32,
        )?;

        // Special handling for bundle project
        if project_name == "bundle" {
            let output_path = release_output_dir.join(project_name).join("digest_1.hex");
            write_commitment_as_evm_hex(&output_path, exe_commit_u32)?;
            let output_path = release_output_dir.join(project_name).join("digest_2.hex");
            write_commitment_as_evm_hex(&output_path, vm_commit_u32)?;
        }

        use scroll_zkvm_types::{types_agg::ProgramCommitment, utils::serialize_vk};
        let app_vk = serialize_vk::serialize(&ProgramCommitment {
            exe: exe_commit_u32,
            vm: vm_commit_u32,
        });

        let app_vk = hex::encode(&app_vk);
        println!("{project_name}: {app_vk}");

        vk_dump[format!("{project_name}_vk")] = serde_json::Value::String(app_vk);

        println!(
            "{LOG_PREFIX} Finished build for config in {:?}",
            start_time.elapsed()
        );
    }

    let output_path = release_output_dir.join("verifier").join("openVmVk.json");
    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    let f = std::fs::File::create(output_path)?;
    serde_json::to_writer(f, &vk_dump)?;
    println!(
        "{LOG_PREFIX} openVmVk.json: {}",
        serde_json::to_string_pretty(&vk_dump)?
    );
    println!("{LOG_PREFIX} VK data written to openVmVk.json");
    Ok(())
}

/// Generates the root verifier assembly code.
fn generate_root_verifier(workspace_dir: &Path, force_overwrite: bool) -> Result<()> {
    println!("{LOG_PREFIX} === Generating Root Verifier Assembly ===");

    let root_verifier_path = workspace_dir
        .join("crates")
        .join("build-guest")
        .join("root_verifier.asm");

    // Check if file exists and skip if in auto mode
    if !force_overwrite && root_verifier_path.exists() {
        println!(
            "{LOG_PREFIX} Root verifier already exists, skipping (use --output-mode force to overwrite)"
        );
        return Ok(());
    }

    let asm = openvm_sdk::Sdk::riscv32().generate_root_verifier_asm();
    std::fs::write(&root_verifier_path, asm).expect("fail to write");

    println!(
        "{LOG_PREFIX} Root verifier generated at: {}",
        root_verifier_path.display()
    );

    Ok(())
}

fn generate_evm_verifier(
    verifier_output_dir: &PathBuf,
    recompute_mode: bool,
    force_overwrite: bool,
) -> Result<()> {
    println!("{LOG_PREFIX} === Dumping EVM VERIFIER ===");
    let path_verifier_sol = verifier_output_dir.join("verifier.sol");
    let path_verifier_bin = verifier_output_dir.join("verifier.bin");
    let path_root_agg_pk = verifier_output_dir.join("root_verifier_vk");

    if force_overwrite || !path_root_agg_pk.exists() {
        openvm_sdk::fs::write_object_to_file(
            &path_root_agg_pk,
            openvm_sdk::Sdk::riscv32().agg_pk().get_agg_vk(),
        )
        .expect("fail to write");
    }

    // Check if files exist and skip if in auto mode
    if !force_overwrite && path_verifier_sol.exists() && path_verifier_bin.exists() {
        println!(
            "{LOG_PREFIX} EVM verifier files already exist, skipping (use --output-mode force to overwrite)"
        );
        return Ok(());
    }

    if let Some(parent) = path_verifier_bin.parent() {
        std::fs::create_dir_all(parent)?;
    }

    let verifier_sol = if recompute_mode {
        verifier::generate_evm_verifier()?
    } else {
        verifier::download_evm_verifier()?
    };
    std::fs::write(&path_verifier_sol, &verifier_sol)?;
    println!("{LOG_PREFIX} verifier_sol written to {path_verifier_sol:?}");

    let verifier_bin = compile_solidity(&verifier_sol);
    std::fs::write(&path_verifier_bin, &verifier_bin)?;
    println!("{LOG_PREFIX} verifier_bin written to {path_verifier_bin:?}");

    Ok(())
}

fn generate_openvm_assets(
    workspace_dir: &PathBuf,
    release_output_dir: &PathBuf,
    force_overwrite: bool,
) -> Result<()> {
    // to use the 'foundry.toml'
    env::set_current_dir(workspace_dir)?;

    generate_root_verifier(workspace_dir, force_overwrite)?;
    generate_evm_verifier(&release_output_dir.join("verifier"), false, force_overwrite)?;
    Ok(())
}

pub fn main() -> Result<()> {
    let cli = Cli::parse();

    println!("{LOG_PREFIX} Generation mode: {:?}", cli.mode);
    println!("{LOG_PREFIX} Will generate both app and openvm assets");

    // Set current directory to the crate's root
    let manifest_dir = env::var("CARGO_MANIFEST_DIR")?;
    env::set_current_dir(&manifest_dir)?;
    println!("{LOG_PREFIX} Running in directory: {}", manifest_dir);

    // Load .env file if present
    dotenv().ok();

    // Determine workspace root
    let metadata = cargo_metadata::MetadataCommand::new().exec()?;
    let workspace_dir = metadata.workspace_root.into_std_path_buf();
    println!("{LOG_PREFIX} Workspace root: {}", workspace_dir.display());

    let release_output_dir: std::path::PathBuf = workspace_dir.join("releases").join(&cli.output);
    std::fs::create_dir_all(&release_output_dir)?;
    println!(
        "{LOG_PREFIX} Release output directory: {}",
        release_output_dir.display()
    );

    println!("{LOG_PREFIX} Generating openvm assets");
    let force_overwrite = matches!(cli.mode, OutputMode::Force);
    generate_openvm_assets(&workspace_dir, &release_output_dir, force_overwrite)?;

    println!("{LOG_PREFIX} Generating app assets (always overwrite)");
    generate_app_assets(&workspace_dir, &release_output_dir)?;

    println!("{LOG_PREFIX} Build process completed successfully.");
    Ok(())
}
